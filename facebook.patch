diff --git mysql-test/suite/perfschema/r/relaylog.result mysql-test/suite/perfschema/r/relaylog.result
index 2b11019..407af93 100644
--- mysql-test/suite/perfschema/r/relaylog.result
+++ mysql-test/suite/perfschema/r/relaylog.result
@@ -61,12 +61,15 @@ where event_name like "%MYSQL_BIN_LOG%"
 EVENT_NAME	COUNT_STAR
 wait/synch/cond/sql/MYSQL_BIN_LOG::COND_done	NONE
 wait/synch/cond/sql/MYSQL_BIN_LOG::prep_xids_cond	NONE
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_binlog_end_pos	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_done	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_flush_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_index	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_log	MANY
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_semisync	MANY
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_semisync_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_xids	NONE
@@ -86,6 +89,7 @@ where event_name like "%MYSQL_RELAY_LOG%"
 EVENT_NAME	COUNT_STAR	SUM_TIMER_WAIT	MIN_TIMER_WAIT	AVG_TIMER_WAIT	MAX_TIMER_WAIT
 wait/synch/cond/sql/MYSQL_RELAY_LOG::COND_done	0	0	0	0	0
 wait/synch/cond/sql/MYSQL_RELAY_LOG::prep_xids_cond	0	0	0	0	0
+wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_binlog_end_pos	0	0	0	0	0
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_commit	0	0	0	0	0
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_commit_queue	0	0	0	0	0
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_done	0	0	0	0	0
@@ -153,12 +157,15 @@ where event_name like "%MYSQL_BIN_LOG%"
 EVENT_NAME	COUNT_STAR
 wait/synch/cond/sql/MYSQL_BIN_LOG::COND_done	NONE
 wait/synch/cond/sql/MYSQL_BIN_LOG::prep_xids_cond	NONE
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_binlog_end_pos	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_commit_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_done	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_flush_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_index	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_log	MANY
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_semisync	MANY
+wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_semisync_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_sync_queue	MANY
 wait/synch/mutex/sql/MYSQL_BIN_LOG::LOCK_xids	NONE
@@ -200,6 +207,7 @@ where event_name like "%MYSQL_RELAY_LOG%"
 EVENT_NAME	COUNT_STAR
 wait/synch/cond/sql/MYSQL_RELAY_LOG::COND_done	NONE
 wait/synch/cond/sql/MYSQL_RELAY_LOG::prep_xids_cond	NONE
+wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_binlog_end_pos	NONE
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_commit	NONE
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_commit_queue	NONE
 wait/synch/mutex/sql/MYSQL_RELAY_LOG::LOCK_done	NONE
diff --git mysql-test/suite/rpl/r/rpl_semi_sync_deadlock.result mysql-test/suite/rpl/r/rpl_semi_sync_deadlock.result
deleted file mode 100644
index f8b24b4..0000000
--- mysql-test/suite/rpl/r/rpl_semi_sync_deadlock.result
+++ /dev/null
@@ -1,21 +0,0 @@
-include/master-slave.inc
-Warnings:
-Note	####	Sending passwords in plain text without SSL/TLS is extremely insecure.
-Note	####	Storing MySQL user name or password information in the master info repository is not secure and is therefore not recommended. Please consider using the USER and PASSWORD connection options for START SLAVE; see the 'START SLAVE Syntax' in the MySQL Manual for more information.
-[connection master]
-include/install_semisync.inc
-SET @debug_save= @@GLOBAL.DEBUG;
-SET GLOBAL rpl_semi_sync_master_timeout= 600000;
-include/sync_slave_sql_with_master.inc
-SET GLOBAL debug= 'd,semi_sync_3-way_deadlock';
-SET DEBUG_SYNC= "before_process_commit_stage_queue WAIT_FOR signal.rotate_finished no_clear_event";
-# Build 10 connections to master server
-# Execute INSERT statement on these 10 connections in parallel
-SET DEBUG_SYNC= "before_rotate_binlog SIGNAL signal.rotate_finished";
-# Rotate binlog file
-FLUSH LOGS;
-SET DEBUG_SYNC= 'RESET';
-SET @@GLOBAL.DEBUG= @debug_save;
-include/sync_slave_sql_with_master.inc
-include/uninstall_semisync.inc
-include/rpl_end.inc
diff --git mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-master.opt mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-master.opt
deleted file mode 100644
index 58029d2..0000000
--- mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-master.opt
+++ /dev/null
@@ -1 +0,0 @@
-$SEMISYNC_PLUGIN_OPT
diff --git mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-slave.opt mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-slave.opt
deleted file mode 100644
index 58029d2..0000000
--- mysql-test/suite/rpl/t/rpl_semi_sync_deadlock-slave.opt
+++ /dev/null
@@ -1 +0,0 @@
-$SEMISYNC_PLUGIN_OPT
diff --git mysql-test/suite/rpl/t/rpl_semi_sync_deadlock.test mysql-test/suite/rpl/t/rpl_semi_sync_deadlock.test
deleted file mode 100644
index 6fa5823..0000000
--- mysql-test/suite/rpl/t/rpl_semi_sync_deadlock.test
+++ /dev/null
@@ -1,102 +0,0 @@
-################################################################################
-# WL#6969    Additional concurrency tests for BGC
-#
-# Concurrency test verifies that there is not 3-way deadlock any more.
-#
-# ################################################################################
---source include/have_debug_sync.inc
---source include/master-slave.inc
---source include/install_semisync.inc
-
-SET @debug_save= @@GLOBAL.DEBUG;
-SET GLOBAL rpl_semi_sync_master_timeout= 600000;
-
---disable_query_log
---disable_result_log
---let $n= 11
---let $i= 1
-while ($i < $n)
-{
-  --eval CREATE TABLE t$i(c1 INT) ENGINE= InnoDB;
-  --inc $i
-}
---enable_result_log
---enable_query_log
-
---source include/sync_slave_sql_with_master.inc
-
---connection master
-SET GLOBAL debug= 'd,semi_sync_3-way_deadlock';
-SET DEBUG_SYNC= "before_process_commit_stage_queue WAIT_FOR signal.rotate_finished no_clear_event";
-
---echo # Build 10 connections to master server
---disable_query_log
---disable_result_log
---let $i= 1
-while ($i < $n)
-{
-  --connect(con$i,127.0.0.1,root,,test,$MASTER_MYPORT,)
-  --inc $i
-}
---enable_result_log
---enable_query_log
-
---echo # Execute INSERT statement on these 10 connections in parallel
---disable_query_log
---disable_result_log
-
---let $i= 1
-while ($i < $n)
-{
-  --connection con$i
-  --send
-  --eval INSERT INTO t$i VALUES(2)
-  --inc $i
-}
---enable_result_log
---enable_query_log
-
---connection master1
-SET DEBUG_SYNC= "before_rotate_binlog SIGNAL signal.rotate_finished";
---real_sleep 3
---echo # Rotate binlog file
-FLUSH LOGS;
-
---disable_query_log
---disable_result_log
---let $i= 1
-while ($i < $n)
-{
-  --connection con$i
-  --reap
-  --inc $i
-}
---enable_result_log
---enable_query_log
-
-# clean up
---connection master
---disable_query_log
---disable_result_log
-# disconnect connections
---let $i= 1
-while ($i < $n)
-{
-  --disconnect con$i
-  --inc $i
-}
-# drop tables
---let $i= 1
-while ($i < $n)
-{
-  --eval DROP TABLE t$i
-  --inc $i
-}
---enable_result_log
---enable_query_log
-SET DEBUG_SYNC= 'RESET';
-SET @@GLOBAL.DEBUG= @debug_save;
---source include/sync_slave_sql_with_master.inc
-
---source include/uninstall_semisync.inc
---source include/rpl_end.inc
diff --git plugin/semisync/semisync_master_plugin.cc plugin/semisync/semisync_master_plugin.cc
index f89eb10..5991039 100644
--- plugin/semisync/semisync_master_plugin.cc
+++ plugin/semisync/semisync_master_plugin.cc
@@ -48,7 +48,7 @@ int repl_semi_request_commit(Trans_param *param)
   return 0;
 }
 
-int repl_semi_report_commit(Trans_param *param)
+int repl_semi_report_before_commit(Trans_param *param)
 {
 
   bool is_real_trans= param->flags & TRANS_IS_REAL_TRANS;
@@ -61,9 +61,14 @@ int repl_semi_report_commit(Trans_param *param)
   return 0;
 }
 
+int repl_semi_report_after_commit(Trans_param *param)
+{
+  return 0;
+}
+
 int repl_semi_report_rollback(Trans_param *param)
 {
-  return repl_semi_report_commit(param);
+  return 0;
 }
 
 int repl_semi_binlog_dump_start(Binlog_transmit_param *param,
@@ -260,9 +265,9 @@ static void fix_rpl_semi_sync_master_enabled(MYSQL_THD thd,
 
 Trans_observer trans_observer = {
   sizeof(Trans_observer),		// len
-
-  repl_semi_report_commit,	// after_commit
-  repl_semi_report_rollback,	// after_rollback
+  repl_semi_report_before_commit,       // before_commit
+  repl_semi_report_after_commit,	// after_commit
+  repl_semi_report_rollback,	        // after_rollback
 };
 
 Binlog_storage_observer storage_observer = {
diff --git sql/binlog.cc sql/binlog.cc
index 3dadc79..e9f4f2e 100644
--- sql/binlog.cc
+++ sql/binlog.cc
@@ -2428,6 +2428,7 @@ MYSQL_BIN_LOG::MYSQL_BIN_LOG(uint *sync_period)
   :bytes_written(0), file_id(1), open_count(1),
    sync_period_ptr(sync_period), sync_counter(0),
    m_prep_xids(0),
+   binlog_end_pos(0),
    is_relay_log(0), signal_cnt(0),
    checksum_alg_reset(BINLOG_CHECKSUM_ALG_UNDEF),
    relay_log_checksum_alg(BINLOG_CHECKSUM_ALG_UNDEF),
@@ -2458,8 +2459,10 @@ void MYSQL_BIN_LOG::cleanup()
     mysql_mutex_destroy(&LOCK_log);
     mysql_mutex_destroy(&LOCK_index);
     mysql_mutex_destroy(&LOCK_commit);
+    mysql_mutex_destroy(&LOCK_semisync);
     mysql_mutex_destroy(&LOCK_sync);
     mysql_mutex_destroy(&LOCK_xids);
+    mysql_mutex_destroy(&LOCK_binlog_end_pos);
     mysql_cond_destroy(&update_cond);
     my_atomic_rwlock_destroy(&m_prep_xids_lock);
     mysql_cond_destroy(&m_prep_xids_cond);
@@ -2474,8 +2477,11 @@ void MYSQL_BIN_LOG::init_pthread_objects()
   MYSQL_LOG::init_pthread_objects();
   mysql_mutex_init(m_key_LOCK_index, &LOCK_index, MY_MUTEX_INIT_SLOW);
   mysql_mutex_init(m_key_LOCK_commit, &LOCK_commit, MY_MUTEX_INIT_FAST);
+  mysql_mutex_init(m_key_LOCK_semisync, &LOCK_semisync, MY_MUTEX_INIT_FAST);
   mysql_mutex_init(m_key_LOCK_sync, &LOCK_sync, MY_MUTEX_INIT_FAST);
   mysql_mutex_init(m_key_LOCK_xids, &LOCK_xids, MY_MUTEX_INIT_FAST);
+  mysql_mutex_init(m_key_LOCK_binlog_end_pos, &LOCK_binlog_end_pos,
+                   MY_MUTEX_INIT_FAST);
   mysql_cond_init(m_key_update_cond, &update_cond, 0);
   my_atomic_rwlock_init(&m_prep_xids_lock);
   mysql_cond_init(m_key_prep_xids_cond, &m_prep_xids_cond, NULL);
@@ -2483,6 +2489,7 @@ void MYSQL_BIN_LOG::init_pthread_objects()
 #ifdef HAVE_PSI_INTERFACE
                    m_key_LOCK_flush_queue,
                    m_key_LOCK_sync_queue,
+                   m_key_LOCK_semisync_queue,
                    m_key_LOCK_commit_queue,
                    m_key_LOCK_done, m_key_COND_done
 #endif
@@ -3200,6 +3207,8 @@ bool MYSQL_BIN_LOG::open_binlog(const char *log_name,
   if (flush_io_cache(&log_file) ||
       mysql_file_sync(log_file.file, MYF(MY_WME)))
     goto err;
+
+  update_binlog_end_pos();
   
   if (write_file_name_to_index_file)
   {
@@ -4735,8 +4744,6 @@ int MYSQL_BIN_LOG::new_file_impl(bool need_lock_log, Format_description_log_even
     mysql_mutex_lock(&LOCK_log);
   else
     mysql_mutex_assert_owner(&LOCK_log);
-  DBUG_EXECUTE_IF("semi_sync_3-way_deadlock",
-                  DEBUG_SYNC(current_thd, "before_rotate_binlog"););
   mysql_mutex_lock(&LOCK_xids);
   /*
     We need to ensure that the number of prepared XIDs are 0.
@@ -4798,12 +4805,22 @@ int MYSQL_BIN_LOG::new_file_impl(bool need_lock_log, Format_description_log_even
     }
     bytes_written += r.data_written;
   }
+
+  // Need flush before updating binlog_end_pos, otherwise dump thread
+  // may give errors.
+  if (flush_io_cache(&log_file))
+  {
+    error = 1;
+    close_on_error = TRUE;
+    goto end;
+  }
+
   /*
     Update needs to be signalled even if there is no rotate event
     log rotation should give the waiting thread a signal to
     discover EOF and move on to the next log.
   */
-  signal_update();
+  update_binlog_end_pos();
 
   old_name=name;
   name=0;				// Don't free name
@@ -4926,7 +4943,7 @@ bool MYSQL_BIN_LOG::after_append_to_relay_log(Master_info *mi)
     }
   }
 
-  signal_update();
+  update_binlog_end_pos();
 
   DBUG_RETURN(error);
 }
@@ -5683,7 +5700,7 @@ bool MYSQL_BIN_LOG::write_incident(Incident_log_event *ev, bool need_lock_log,
     if (!error && !(error= flush_and_sync()))
     {
       bool check_purge= false;
-      signal_update();
+      update_binlog_end_pos();
       error= rotate(true, &check_purge);
       if (!error && check_purge)
         purge();
@@ -5867,9 +5884,9 @@ int MYSQL_BIN_LOG::wait_for_update_relay_log(THD* thd, const struct timespec *ti
   @retval    0          if got signalled on update
   @retval    non-0      if wait timeout elapsed
   @note
-    LOCK_log must be taken before calling this function.
-    LOCK_log is being released while the thread is waiting.
-    LOCK_log is released by the caller.
+    LOCK_binlog_end_pos must be taken before calling this function.
+    LOCK_binlog_end_pos is being released while the thread is waiting.
+    LOCK_binlog_end_pos is released by the caller.
 */
 
 int MYSQL_BIN_LOG::wait_for_update_bin_log(THD* thd,
@@ -5879,9 +5896,9 @@ int MYSQL_BIN_LOG::wait_for_update_bin_log(THD* thd,
   DBUG_ENTER("wait_for_update_bin_log");
 
   if (!timeout)
-    mysql_cond_wait(&update_cond, &LOCK_log);
+    mysql_cond_wait(&update_cond, &LOCK_binlog_end_pos);
   else
-    ret= mysql_cond_timedwait(&update_cond, &LOCK_log,
+    ret= mysql_cond_timedwait(&update_cond, &LOCK_binlog_end_pos,
                               const_cast<struct timespec *>(timeout));
   DBUG_RETURN(ret);
 }
@@ -5918,7 +5935,7 @@ void MYSQL_BIN_LOG::close(uint exiting)
                   relay_log_checksum_alg != BINLOG_CHECKSUM_ALG_UNDEF);
       s.write(&log_file);
       bytes_written+= s.data_written;
-      signal_update();
+      update_binlog_end_pos();
     }
 #endif /* HAVE_REPLICATION */
 
@@ -5991,6 +6008,26 @@ void MYSQL_BIN_LOG::signal_update()
   DBUG_VOID_RETURN;
 }
 
+/*
+ * Caller must hold LOCK_log mutex when the file is in use.
+ */
+void MYSQL_BIN_LOG::update_binlog_end_pos()
+{
+  /*
+    binlog_end_pos is used only on master's binlog right now. It is possible
+    to use it on relay log.
+  */
+  if (is_relay_log)
+    signal_update();
+  else
+  {
+    lock_binlog_end_pos();
+    binlog_end_pos = my_b_tell(&log_file);
+    signal_update();
+    unlock_binlog_end_pos();
+  }
+}
+
 /****** transaction coordinator log for 2pc - binlog() based solution ******/
 
 /**
@@ -6506,7 +6543,7 @@ MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first)
         /*
           storage engine commit
         */
-        if (ha_commit_low(head, all, false))
+        if (ha_commit_low(head, all))
           head->commit_error= THD::CE_COMMIT_ERROR;
       }
       DBUG_PRINT("debug", ("commit_error: %d, flags.pending: %s",
@@ -6525,37 +6562,40 @@ MYSQL_BIN_LOG::process_commit_stage_queue(THD *thd, THD *first)
 }
 
 /**
-  Process after commit for a sequence of sessions.
+  Scans the semisync queue and calls before_commit hook
+  using the last thread in the queue.
 
-  @param thd The "master" thread
-  @param first First thread in the queue of threads to commit
- */
+  @param queue_head  Head of the semisync stage queue.
 
+  Note that this should be used only for semisync wait.
+*/
 void
-MYSQL_BIN_LOG::process_after_commit_stage_queue(THD *thd, THD *first)
-{
-  Thread_excursion excursion(thd);
-  for (THD *head= first; head; head= head->next_to_commit)
-  {
-    if (head->transaction.flags.run_hooks &&
-        head->commit_error == THD::CE_NONE)
-    {
+MYSQL_BIN_LOG::process_semisync_stage_queue(THD *queue_head)
+{
+   THD *last_thd = NULL;
+   for (THD *thd = queue_head; thd != NULL; thd = thd->next_to_commit)
+   {
+      // run_hooks is set to true in ordered_commit() if storage
+      // engine commit is required.
+      if (thd->transaction.flags.run_hooks &&
+          thd->commit_error == THD::CE_NONE)
+      {
+        last_thd = thd;
+        // setting run_hooks to false allows other parts of the system to
+        // check if before commit hook is called for this thread.
+        // Also this avoids assertion in finish_commit.
+        thd->transaction.flags.run_hooks = false;
+      }
+   }
 
-      /*
-        TODO: This hook here should probably move outside/below this
-              if and be the only after_commit invocation left in the
-              code.
-      */
-      excursion.try_to_attach_to(head);
-      bool all= head->transaction.flags.real_commit;
-      (void) RUN_HOOK(transaction, after_commit, (head, all));
-      /*
-        When after_commit finished for the transaction, clear the run_hooks flag.
-        This allow other parts of the system to check if after_commit was called.
-      */
-      head->transaction.flags.run_hooks= false;
-    }
-  }
+   if (last_thd)
+   {
+     // Since flush ordered is maintained even in the semisync stage
+     // calling hook for the last valid thd is sufficient since it
+     // will have the maximum binlog position.
+     (void) RUN_HOOK(transaction, before_commit,
+                     (last_thd, last_thd->transaction.flags.real_commit));
+   }
 }
 
 #ifndef DBUG_OFF
@@ -6563,6 +6603,7 @@ MYSQL_BIN_LOG::process_after_commit_stage_queue(THD *thd, THD *first)
 static const char* g_stage_name[] = {
   "FLUSH",
   "SYNC",
+  "SEMISYNC",
   "COMMIT",
 };
 #endif
@@ -6585,10 +6626,11 @@ static const char* g_stage_name[] = {
   The function will lock the stage mutex if it was designated the
   leader for the phase.
 
-  @param thd    Session structure
-  @param stage  The stage to enter
-  @param queue  Queue of threads to enqueue for the stage
-  @param stage_mutex Mutex for the stage
+  @param thd                Session structure
+  @param stage              The stage to enter
+  @param queue              Queue of threads to enqueue for the stage
+  @param leave_mutex        Mutex which will be released
+  @param enter_mutex        Mutex which will be acquired
 
   @retval true  The thread should "bail out" and go waiting for the
                 commit to finish
@@ -6690,25 +6732,13 @@ MYSQL_BIN_LOG::finish_commit(THD *thd)
       storage engine commit
     */
     if (thd->commit_error == THD::CE_NONE &&
-        ha_commit_low(thd, all, false))
+        ha_commit_low(thd, all))
       thd->commit_error= THD::CE_COMMIT_ERROR;
     /*
       Decrement the prepared XID counter after storage engine commit
     */
     if (thd->transaction.flags.xid_written)
       dec_prep_xids(thd);
-    /*
-      If commit succeeded, we call the after_commit hook
-
-      TODO: This hook here should probably move outside/below this
-            if and be the only after_commit invocation left in the
-            code.
-    */
-    if ((thd->commit_error == THD::CE_NONE) && thd->transaction.flags.run_hooks)
-    {
-      (void) RUN_HOOK(transaction, after_commit, (thd, all));
-      thd->transaction.flags.run_hooks= false;
-    }
   }
   else if (thd->transaction.flags.xid_written)
     dec_prep_xids(thd);
@@ -6861,7 +6891,14 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit)
       flush_error= ER_ERROR_ON_WRITE;
     }
 
-    signal_update();
+    /*
+      Update the last valid position after the after_flush hook has
+      executed. Doing so guarantees that the hook is executed before
+      the before/after_send_hooks on the dump thread, preventing race
+      conditions between the group_commit here and the dump threads.
+    */
+    update_binlog_end_pos();
+
     DBUG_EXECUTE_IF("crash_commit_after_log", DBUG_SUICIDE(););
   }
 
@@ -6892,6 +6929,17 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit)
   if (need_LOCK_log)
     mysql_mutex_unlock(&LOCK_log);
 
+  if (change_stage(thd, Stage_manager::SEMISYNC_STAGE, final_queue,
+                   &LOCK_sync, &LOCK_semisync))
+  {
+    DBUG_PRINT("return", ("Thread ID: %lu, commit_error: %d",
+                          thd->thread_id, thd->commit_error));
+    DBUG_RETURN(finish_commit(thd));
+  }
+  THD *semisync_queue =
+    stage_manager.fetch_queue_for(Stage_manager::SEMISYNC_STAGE);
+  process_semisync_stage_queue(semisync_queue);
+
   /*
     Stage #3: Commit all transactions in order.
 
@@ -6904,26 +6952,19 @@ int MYSQL_BIN_LOG::ordered_commit(THD *thd, bool all, bool skip_commit)
   if (opt_binlog_order_commits)
   {
     if (change_stage(thd, Stage_manager::COMMIT_STAGE,
-                     final_queue, &LOCK_sync, &LOCK_commit))
+                     semisync_queue, &LOCK_semisync, &LOCK_commit))
     {
       DBUG_PRINT("return", ("Thread ID: %lu, commit_error: %d",
                             thd->thread_id, thd->commit_error));
       DBUG_RETURN(finish_commit(thd));
     }
     THD *commit_queue= stage_manager.fetch_queue_for(Stage_manager::COMMIT_STAGE);
-    DBUG_EXECUTE_IF("semi_sync_3-way_deadlock",
-                    DEBUG_SYNC(thd, "before_process_commit_stage_queue"););
     process_commit_stage_queue(thd, commit_queue);
     mysql_mutex_unlock(&LOCK_commit);
-    /*
-      Process after_commit after LOCK_commit is released for avoiding
-      3-way deadlock among user thread, rotate thread and dump thread.
-    */
-    process_after_commit_stage_queue(thd, commit_queue);
     final_queue= commit_queue;
   }
   else
-    mysql_mutex_unlock(&LOCK_sync);
+    mysql_mutex_unlock(&LOCK_semisync);
 
   /* Commit done so signal all waiting threads */
   stage_manager.signal_done(final_queue);
diff --git sql/binlog.h sql/binlog.h
index 4fec6c0..76bf38b 100644
--- sql/binlog.h
+++ sql/binlog.h
@@ -103,6 +103,7 @@ public:
   enum StageID {
     FLUSH_STAGE,
     SYNC_STAGE,
+    SEMISYNC_STAGE,
     COMMIT_STAGE,
     STAGE_COUNTER
   };
@@ -111,6 +112,7 @@ public:
 #ifdef HAVE_PSI_INTERFACE
             PSI_mutex_key key_LOCK_flush_queue,
             PSI_mutex_key key_LOCK_sync_queue,
+            PSI_mutex_key key_LOCK_semisync_queue,
             PSI_mutex_key key_LOCK_commit_queue,
             PSI_mutex_key key_LOCK_done,
             PSI_cond_key key_COND_done
@@ -133,6 +135,11 @@ public:
                              key_LOCK_sync_queue
 #endif
                              );
+    m_queue[SEMISYNC_STAGE].init(
+#ifdef HAVE_PSI_INTERFACE
+                             key_LOCK_semisync_queue
+#endif
+                             );
     m_queue[COMMIT_STAGE].init(
 #ifdef HAVE_PSI_INTERFACE
                                key_LOCK_commit_queue
@@ -242,15 +249,20 @@ class MYSQL_BIN_LOG: public TC_LOG, private MYSQL_LOG
   PSI_mutex_key m_key_COND_done;
 
   PSI_mutex_key m_key_LOCK_commit_queue;
+  PSI_mutex_key m_key_LOCK_semisync_queue;
   PSI_mutex_key m_key_LOCK_done;
   PSI_mutex_key m_key_LOCK_flush_queue;
   PSI_mutex_key m_key_LOCK_sync_queue;
   /** The instrumentation key to use for @ LOCK_commit. */
   PSI_mutex_key m_key_LOCK_commit;
+  /** The instrumentation key to use for @ LOCK_semisync. */
+  PSI_mutex_key m_key_LOCK_semisync;
   /** The instrumentation key to use for @ LOCK_sync. */
   PSI_mutex_key m_key_LOCK_sync;
   /** The instrumentation key to use for @ LOCK_xids. */
   PSI_mutex_key m_key_LOCK_xids;
+  /** The instrumentation key to use for @ LOCK_binlog. */
+  PSI_mutex_key m_key_LOCK_binlog_end_pos;
   /** The instrumentation key to use for @ update_cond. */
   PSI_cond_key m_key_update_cond;
   /** The instrumentation key to use for @ prep_xids_cond. */
@@ -263,8 +275,10 @@ class MYSQL_BIN_LOG: public TC_LOG, private MYSQL_LOG
   /* POSIX thread objects are inited by init_pthread_objects() */
   mysql_mutex_t LOCK_index;
   mysql_mutex_t LOCK_commit;
+  mysql_mutex_t LOCK_semisync;
   mysql_mutex_t LOCK_sync;
   mysql_mutex_t LOCK_xids;
+  mysql_mutex_t LOCK_binlog_end_pos;
   mysql_cond_t update_cond;
   ulonglong bytes_written;
   IO_CACHE index_file;
@@ -310,6 +324,7 @@ class MYSQL_BIN_LOG: public TC_LOG, private MYSQL_LOG
   my_atomic_rwlock_t m_prep_xids_lock;
   mysql_cond_t m_prep_xids_cond;
   volatile int32 m_prep_xids;
+  volatile my_off_t binlog_end_pos;
 
   /**
     Increment the prepared XID counter.
@@ -429,12 +444,15 @@ public:
   void set_psi_keys(PSI_mutex_key key_LOCK_index,
                     PSI_mutex_key key_LOCK_commit,
                     PSI_mutex_key key_LOCK_commit_queue,
+                    PSI_mutex_key key_LOCK_semisync,
+                    PSI_mutex_key key_LOCK_semisync_queue,
                     PSI_mutex_key key_LOCK_done,
                     PSI_mutex_key key_LOCK_flush_queue,
                     PSI_mutex_key key_LOCK_log,
                     PSI_mutex_key key_LOCK_sync,
                     PSI_mutex_key key_LOCK_sync_queue,
                     PSI_mutex_key key_LOCK_xids,
+                    PSI_mutex_key key_LOCK_binlog_end_pos,
                     PSI_cond_key key_COND_done,
                     PSI_cond_key key_update_cond,
                     PSI_cond_key key_prep_xids_cond,
@@ -444,6 +462,7 @@ public:
     m_key_COND_done= key_COND_done;
 
     m_key_LOCK_commit_queue= key_LOCK_commit_queue;
+    m_key_LOCK_semisync_queue = key_LOCK_semisync_queue;
     m_key_LOCK_done= key_LOCK_done;
     m_key_LOCK_flush_queue= key_LOCK_flush_queue;
     m_key_LOCK_sync_queue= key_LOCK_sync_queue;
@@ -451,8 +470,10 @@ public:
     m_key_LOCK_index= key_LOCK_index;
     m_key_LOCK_log= key_LOCK_log;
     m_key_LOCK_commit= key_LOCK_commit;
+    m_key_LOCK_semisync = key_LOCK_semisync;
     m_key_LOCK_sync= key_LOCK_sync;
     m_key_LOCK_xids= key_LOCK_xids;
+    m_key_LOCK_binlog_end_pos = key_LOCK_binlog_end_pos;
     m_key_update_cond= key_update_cond;
     m_key_prep_xids_cond= key_prep_xids_cond;
     m_key_file_log= key_file_log;
@@ -509,8 +530,8 @@ private:
   int flush_cache_to_file(my_off_t *flush_end_pos);
   int finish_commit(THD *thd);
   std::pair<bool, bool> sync_binlog_file(bool force);
+  void process_semisync_stage_queue(THD *queue_head);
   void process_commit_stage_queue(THD *thd, THD *queue);
-  void process_after_commit_stage_queue(THD *thd, THD *first);
   int process_flush_stage_queue(my_off_t *total_bytes_var, bool *rotate_var,
                                 THD **out_queue_var);
   int ordered_commit(THD *thd, bool all, bool skip_commit = false);
@@ -552,6 +573,7 @@ public:
   }
   void set_max_size(ulong max_size_arg);
   void signal_update();
+  void update_binlog_end_pos();
   int wait_for_update_relay_log(THD* thd, const struct timespec * timeout);
   int  wait_for_update_bin_log(THD* thd, const struct timespec * timeout);
 public:
@@ -673,6 +695,26 @@ public:
   inline void unlock_index() { mysql_mutex_unlock(&LOCK_index);}
   inline IO_CACHE *get_index_file() { return &index_file;}
   inline uint32 get_open_count() { return open_count; }
+  /*
+    It is called by the threads(e.g. dump thread) which want to read
+    hot log without LOCK_log protection.
+  */
+  my_off_t get_binlog_end_pos()
+  {
+    mysql_mutex_assert_not_owner(&LOCK_log);
+    mysql_mutex_assert_owner(&LOCK_binlog_end_pos);
+    return binlog_end_pos;
+  }
+
+  my_off_t get_binlog_end_pos_without_lock()
+  {
+    mysql_mutex_assert_not_owner(&LOCK_log);
+    mysql_mutex_assert_not_owner(&LOCK_binlog_end_pos);
+    return binlog_end_pos;
+  }
+  mysql_mutex_t* get_binlog_end_pos_lock() { return &LOCK_binlog_end_pos; }
+  void lock_binlog_end_pos() { mysql_mutex_lock(&LOCK_binlog_end_pos); }
+  void unlock_binlog_end_pos() { mysql_mutex_unlock(&LOCK_binlog_end_pos); }
 };
 
 typedef struct st_load_file_info
diff --git sql/handler.cc sql/handler.cc
index bdb95c5..aa5bdf1 100644
--- sql/handler.cc
+++ sql/handler.cc
@@ -417,7 +417,6 @@ handlerton *ha_checktype(THD *thd, enum legacy_db_type database_type,
     return NULL;
   }
 
-  (void) RUN_HOOK(transaction, after_rollback, (thd, FALSE));
 
   switch (database_type) {
   case DB_TYPE_MRG_ISAM:
@@ -1472,12 +1471,9 @@ end:
                    issued by DDL. Is not set when called
                    at the end of statement, even if
                    autocommit=1.
-  @param[in]  run_after_commit
-                   True by default, otherwise, does not execute
-                   the after_commit hook in the function.
 */
 
-int ha_commit_low(THD *thd, bool all, bool run_after_commit)
+int ha_commit_low(THD *thd, bool all)
 {
   int error=0;
   THD_TRANS *trans=all ? &thd->transaction.all : &thd->transaction.stmt;
@@ -1519,19 +1515,6 @@ int ha_commit_low(THD *thd, bool all, bool run_after_commit)
     was called.
   */
   thd->transaction.flags.commit_low= false;
-  if (run_after_commit && thd->transaction.flags.run_hooks)
-  {
-    /*
-       If commit succeeded, we call the after_commit hook.
-
-       TODO: Investigate if this can be refactored so that there is
-             only one invocation of this hook in the code (in
-             MYSQL_LOG_BIN::finish_commit).
-    */
-    if (!error)
-      (void) RUN_HOOK(transaction, after_commit, (thd, all));
-    thd->transaction.flags.run_hooks= false;
-  }
   DBUG_RETURN(error);
 }
 
@@ -1574,7 +1557,6 @@ int ha_rollback_low(THD *thd, bool all)
       thd->transaction.xid_state.xa_state != XA_NOTR)
     thd->transaction.xid_state.rm_error= thd->get_stmt_da()->sql_errno();
 
-  (void) RUN_HOOK(transaction, after_rollback, (thd, all));
   return error;
 }
 
diff --git sql/handler.h sql/handler.h
index effe818..4e6a72e 100644
--- sql/handler.h
+++ sql/handler.h
@@ -3426,7 +3426,7 @@ int ha_recover(HASH *commit_list);
  intended to be used by the transaction coordinators to
  commit/prepare/rollback transactions in the engines.
 */
-int ha_commit_low(THD *thd, bool all, bool run_after_commit= true);
+int ha_commit_low(THD *thd, bool all);
 int ha_prepare_low(THD *thd, bool all);
 int ha_rollback_low(THD *thd, bool all);
 
diff --git sql/log_event.cc sql/log_event.cc
index 01a012f..35c25d3 100644
--- sql/log_event.cc
+++ sql/log_event.cc
@@ -1184,7 +1184,6 @@ bool Log_event::write_header(IO_CACHE* file, ulong event_data_length)
 */
 
 int Log_event::read_log_event(IO_CACHE* file, String* packet,
-                              mysql_mutex_t* log_lock,
                               uint8 checksum_alg_arg,
                               const char *log_file_name_arg,
                               bool* is_binlog_active)
@@ -1195,11 +1194,36 @@ int Log_event::read_log_event(IO_CACHE* file, String* packet,
   uchar ev_offset= packet->length();
   DBUG_ENTER("Log_event::read_log_event(IO_CACHE *, String *, mysql_mutex_t, uint8)");
 
-  if (log_lock)
-    mysql_mutex_lock(log_lock);
-
-  if (log_file_name_arg)
+  if (log_file_name_arg && is_binlog_active)
     *is_binlog_active= mysql_bin_log.is_active(log_file_name_arg);
+  /*
+    If the log_file_name_arg is active and we have read up to
+    binlog_end_pos, return LOG_READ_BINLOG_LAST_VALID_POS so that IO
+    thread will wait until binlog is updated
+  */
+  /*
+    Note that even though is_active can give stale value, it doesn't cause
+    problems. Let's say is_active is true although it's actually false
+    this may or may not give LOG_READ_BINLOG_LAST_VALID_POS depending on
+    second condition. If it doesn't give LOG_READ_BINLOG_LAST_VALID_POS,
+    it's fine because we should anyway need to read.
+
+    If it gives LOG_READ_BINLOG_LAST_VALID_POS, there is is_active check
+    after acquiring lock_binlog_end_pos in mysql_binlog_send before going to
+    wait for binlog update. Acquiring lock_binlog_end_pos each time we
+    read an event increases mutex contention. This corner case occurs
+    rarely only during binlog is rotated.
+
+    mysql_bin_log.binlog_end_pos() == my_b_tell(file) ensures that we don't read
+    past the last valid position in binlog.
+  */
+  if (mysql_bin_log.is_active(log_file_name_arg) &&
+      mysql_bin_log.get_binlog_end_pos_without_lock()
+        == my_b_tell(file))
+  {
+    result= LOG_READ_BINLOG_LAST_VALID_POS;
+    goto end;
+  }
 
   if (my_b_read(file, (uchar*) buf, sizeof(buf)))
   {
@@ -1293,8 +1317,6 @@ int Log_event::read_log_event(IO_CACHE* file, String* packet,
   }
 
 end:
-  if (log_lock)
-    mysql_mutex_unlock(log_lock);
   DBUG_PRINT("info", ("read_log_event returns %d", result));
   DBUG_RETURN(result);
 }
diff --git sql/log_event.h sql/log_event.h
index 22661c5..e58f4dc 100644
--- sql/log_event.h
+++ sql/log_event.h
@@ -90,6 +90,7 @@ typedef struct st_db_worker_hash_entry db_worker_hash_entry;
 #define LOG_READ_TRUNC  -6
 #define LOG_READ_TOO_LARGE -7
 #define LOG_READ_CHECKSUM_FAILURE -8
+#define LOG_READ_BINLOG_LAST_VALID_POS -9
 
 #define LOG_EVENT_OFFSET 4
 
@@ -1207,7 +1208,6 @@ public:
     @retval LOG_READ_TOO_LARGE  event too large
    */
   static int read_log_event(IO_CACHE* file, String* packet,
-                            mysql_mutex_t* log_lock,
                             uint8 checksum_alg_arg,
                             const char *log_file_name_arg= NULL,
                             bool* is_binlog_active= NULL);
diff --git sql/mysqld.cc sql/mysqld.cc
index 44aa1e5..e0d4ebe 100644
--- sql/mysqld.cc
+++ sql/mysqld.cc
@@ -3749,12 +3749,15 @@ int init_common_variables()
   mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,
                              key_BINLOG_LOCK_commit,
                              key_BINLOG_LOCK_commit_queue,
+                             key_BINLOG_LOCK_semisync,
+                             key_BINLOG_LOCK_semisync_queue,
                              key_BINLOG_LOCK_done,
                              key_BINLOG_LOCK_flush_queue,
                              key_BINLOG_LOCK_log,
                              key_BINLOG_LOCK_sync,
                              key_BINLOG_LOCK_sync_queue,
                              key_BINLOG_LOCK_xids,
+                             key_BINLOG_LOCK_binlog_end_pos,
                              key_BINLOG_COND_done,
                              key_BINLOG_update_cond,
                              key_BINLOG_prep_xids_cond,
@@ -9339,6 +9342,8 @@ PSI_mutex_key key_LOCK_des_key_file;
 
 PSI_mutex_key key_BINLOG_LOCK_commit;
 PSI_mutex_key key_BINLOG_LOCK_commit_queue;
+PSI_mutex_key key_BINLOG_LOCK_semisync;
+PSI_mutex_key key_BINLOG_LOCK_semisync_queue;
 PSI_mutex_key key_BINLOG_LOCK_done;
 PSI_mutex_key key_BINLOG_LOCK_flush_queue;
 PSI_mutex_key key_BINLOG_LOCK_index;
@@ -9346,6 +9351,7 @@ PSI_mutex_key key_BINLOG_LOCK_log;
 PSI_mutex_key key_BINLOG_LOCK_sync;
 PSI_mutex_key key_BINLOG_LOCK_sync_queue;
 PSI_mutex_key key_BINLOG_LOCK_xids;
+PSI_mutex_key key_BINLOG_LOCK_binlog_end_pos;
 PSI_mutex_key
   key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,
   key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,
@@ -9370,6 +9376,8 @@ PSI_mutex_key
   key_LOCK_log_throttle_qni;
 PSI_mutex_key key_RELAYLOG_LOCK_commit;
 PSI_mutex_key key_RELAYLOG_LOCK_commit_queue;
+PSI_mutex_key key_RELAYLOG_LOCK_semisync;
+PSI_mutex_key key_RELAYLOG_LOCK_semisync_queue;
 PSI_mutex_key key_RELAYLOG_LOCK_done;
 PSI_mutex_key key_RELAYLOG_LOCK_flush_queue;
 PSI_mutex_key key_RELAYLOG_LOCK_index;
@@ -9377,6 +9385,7 @@ PSI_mutex_key key_RELAYLOG_LOCK_log;
 PSI_mutex_key key_RELAYLOG_LOCK_sync;
 PSI_mutex_key key_RELAYLOG_LOCK_sync_queue;
 PSI_mutex_key key_RELAYLOG_LOCK_xids;
+PSI_mutex_key key_RELAYLOG_LOCK_binlog_end_pos;
 PSI_mutex_key key_LOCK_sql_rand;
 PSI_mutex_key key_gtid_ensure_index_mutex;
 PSI_mutex_key key_LOCK_thread_created;
@@ -9396,6 +9405,8 @@ static PSI_mutex_info all_server_mutexes[]=
 
   { &key_BINLOG_LOCK_commit, "MYSQL_BIN_LOG::LOCK_commit", 0 },
   { &key_BINLOG_LOCK_commit_queue, "MYSQL_BIN_LOG::LOCK_commit_queue", 0 },
+  { &key_BINLOG_LOCK_semisync, "MYSQL_BIN_LOG::LOCK_semisync", 0 },
+  { &key_BINLOG_LOCK_semisync_queue, "MYSQL_BIN_LOG::LOCK_semisync_queue", 0 },
   { &key_BINLOG_LOCK_done, "MYSQL_BIN_LOG::LOCK_done", 0 },
   { &key_BINLOG_LOCK_flush_queue, "MYSQL_BIN_LOG::LOCK_flush_queue", 0 },
   { &key_BINLOG_LOCK_index, "MYSQL_BIN_LOG::LOCK_index", 0},
@@ -9403,6 +9414,7 @@ static PSI_mutex_info all_server_mutexes[]=
   { &key_BINLOG_LOCK_sync, "MYSQL_BIN_LOG::LOCK_sync", 0},
   { &key_BINLOG_LOCK_sync_queue, "MYSQL_BIN_LOG::LOCK_sync_queue", 0 },
   { &key_BINLOG_LOCK_xids, "MYSQL_BIN_LOG::LOCK_xids", 0 },
+  { &key_BINLOG_LOCK_binlog_end_pos, "MYSQL_BIN_LOG::LOCK_binlog_end_pos", 0 },
   { &key_RELAYLOG_LOCK_commit, "MYSQL_RELAY_LOG::LOCK_commit", 0},
   { &key_RELAYLOG_LOCK_commit_queue, "MYSQL_RELAY_LOG::LOCK_commit_queue", 0 },
   { &key_RELAYLOG_LOCK_done, "MYSQL_RELAY_LOG::LOCK_done", 0 },
@@ -9412,6 +9424,8 @@ static PSI_mutex_info all_server_mutexes[]=
   { &key_RELAYLOG_LOCK_sync, "MYSQL_RELAY_LOG::LOCK_sync", 0},
   { &key_RELAYLOG_LOCK_sync_queue, "MYSQL_RELAY_LOG::LOCK_sync_queue", 0 },
   { &key_RELAYLOG_LOCK_xids, "MYSQL_RELAY_LOG::LOCK_xids", 0},
+  { &key_RELAYLOG_LOCK_binlog_end_pos,
+    "MYSQL_RELAY_LOG::LOCK_binlog_end_pos", 0},
   { &key_delayed_insert_mutex, "Delayed_insert::mutex", 0},
   { &key_hash_filo_lock, "hash_filo::lock", 0},
   { &key_LOCK_active_mi, "LOCK_active_mi", PSI_FLAG_GLOBAL},
diff --git sql/mysqld.h sql/mysqld.h
index c586c2b..a04d7dc 100644
--- sql/mysqld.h
+++ sql/mysqld.h
@@ -306,6 +306,8 @@ extern PSI_mutex_key key_LOCK_des_key_file;
 
 extern PSI_mutex_key key_BINLOG_LOCK_commit;
 extern PSI_mutex_key key_BINLOG_LOCK_commit_queue;
+extern PSI_mutex_key key_BINLOG_LOCK_semisync;
+extern PSI_mutex_key key_BINLOG_LOCK_semisync_queue;
 extern PSI_mutex_key key_BINLOG_LOCK_done;
 extern PSI_mutex_key key_BINLOG_LOCK_flush_queue;
 extern PSI_mutex_key key_BINLOG_LOCK_index;
@@ -313,6 +315,7 @@ extern PSI_mutex_key key_BINLOG_LOCK_log;
 extern PSI_mutex_key key_BINLOG_LOCK_sync;
 extern PSI_mutex_key key_BINLOG_LOCK_sync_queue;
 extern PSI_mutex_key key_BINLOG_LOCK_xids;
+extern PSI_mutex_key key_BINLOG_LOCK_binlog_end_pos;
 extern PSI_mutex_key
   key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,
   key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,
@@ -337,6 +340,8 @@ extern PSI_mutex_key
   key_LOCK_log_throttle_qni;
 extern PSI_mutex_key key_RELAYLOG_LOCK_commit;
 extern PSI_mutex_key key_RELAYLOG_LOCK_commit_queue;
+extern PSI_mutex_key key_RELAYLOG_LOCK_semisync;
+extern PSI_mutex_key key_RELAYLOG_LOCK_semisync_queue;
 extern PSI_mutex_key key_RELAYLOG_LOCK_done;
 extern PSI_mutex_key key_RELAYLOG_LOCK_flush_queue;
 extern PSI_mutex_key key_RELAYLOG_LOCK_index;
@@ -344,6 +349,7 @@ extern PSI_mutex_key key_RELAYLOG_LOCK_log;
 extern PSI_mutex_key key_RELAYLOG_LOCK_sync;
 extern PSI_mutex_key key_RELAYLOG_LOCK_sync_queue;
 extern PSI_mutex_key key_RELAYLOG_LOCK_xids;
+extern PSI_mutex_key key_RELAYLOG_LOCK_binlog_end_pos;
 extern PSI_mutex_key key_LOCK_sql_rand;
 extern PSI_mutex_key key_gtid_ensure_index_mutex;
 extern PSI_mutex_key key_LOCK_thread_created;
diff --git sql/replication.h sql/replication.h
index 865df60..13a825a 100644
--- sql/replication.h
+++ sql/replication.h
@@ -57,6 +57,19 @@ typedef struct Trans_observer {
   uint32 len;
 
   /**
+     This callback is called before transaction commit
+     and after binlog sync.
+
+     For both non-transactional tables and transactional
+     tables this is called after binlog sync.
+
+     @param param The parameter for transaction observers
+
+     @retval 0 Sucess
+     @retval 1 Failure
+  */
+  int (*before_commit)(Trans_param *param);
+  /**
      This callback is called after transaction commit
      
      This callback is called right after commit to storage engines for
diff --git sql/rpl_handler.cc sql/rpl_handler.cc
index 9ec4902..daa95fb 100644
--- sql/rpl_handler.cc
+++ sql/rpl_handler.cc
@@ -216,6 +216,25 @@ void delegates_destroy()
   delete_dynamic(plugins)
 
 
+int Trans_delegate::before_commit(THD *thd, bool all)
+{
+  DBUG_ENTER("Trans_delegate::before_commit");
+  Trans_param param = { 0, 0, 0, 0 };
+  bool is_real_trans= (all || thd->transaction.all.ha_list == 0);
+
+  if (is_real_trans)
+    param.flags = true;
+
+  thd->get_trans_fixed_pos(&param.log_file, &param.log_pos);
+
+  DBUG_PRINT("enter", ("log_file: %s, log_pos: %llu",
+                       param.log_file, param.log_pos));
+
+  int ret= 0;
+  FOREACH_OBSERVER(ret, before_commit, thd, (&param));
+  DBUG_RETURN(ret);
+}
+
 int Trans_delegate::after_commit(THD *thd, bool all)
 {
   DBUG_ENTER("Trans_delegate::after_commit");
diff --git sql/rpl_master.cc sql/rpl_master.cc
index cdb5ace..4cb99d7 100644
--- sql/rpl_master.cc
+++ sql/rpl_master.cc
@@ -520,7 +520,7 @@ static int send_file(THD *thd)
 
 int test_for_non_eof_log_read_errors(int error, const char **errmsg)
 {
-  if (error == LOG_READ_EOF)
+  if (error == LOG_READ_EOF || error == LOG_READ_BINLOG_LAST_VALID_POS)
     return 0;
   my_errno= ER_MASTER_FATAL_ERROR_READING_BINLOG;
   switch (error) {
@@ -858,7 +858,6 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
   const char *errmsg = "Unknown error";
   char error_text[MAX_SLAVE_ERRMSG]; // to be send to slave via my_message()
   NET* net = &thd->net;
-  mysql_mutex_t *log_lock;
   mysql_cond_t *log_cond;
   uint8 current_checksum_alg= BINLOG_CHECKSUM_ALG_UNDEF;
   Format_description_log_event fdle(BINLOG_VERSION), *p_fdle= &fdle;
@@ -1049,13 +1048,7 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
   */
   thd->variables.max_allowed_packet= MAX_MAX_ALLOWED_PACKET;
 
-  /*
-    We can set log_lock now, it does not move (it's a member of
-    mysql_bin_log, and it's already inited, and it will be destroyed
-    only at shutdown).
-  */
   p_coord->pos= pos; // the first hb matches the slave's last seen value
-  log_lock= mysql_bin_log.get_log_lock();
   log_cond= mysql_bin_log.get_log_cond();
   if (pos > BIN_LOG_HEADER_SIZE)
   {
@@ -1069,7 +1062,8 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
        Try to find a Format_description_log_event at the beginning of
        the binlog
      */
-    if (!(error = Log_event::read_log_event(&log, packet, log_lock, 0)))
+    if (!(error = Log_event::read_log_event(&log, packet, 0,
+                                            log_file_name)))
     { 
       DBUG_PRINT("info", ("read_log_event returned 0 on line %d", __LINE__));
       /*
@@ -1162,14 +1156,8 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
     if (reset_transmit_packet(thd, NO_FLAG, &ev_offset, &errmsg,
                               observe_transmission))
       GOTO_ERR;
-    DBUG_EXECUTE_IF("semi_sync_3-way_deadlock",
-                    {
-                      const char act[]= "now wait_for signal.rotate_finished no_clear_event";
-                      DBUG_ASSERT(!debug_sync_set_action(current_thd,
-                                                         STRING_WITH_LEN(act)));
-                    };);
     bool is_active_binlog= false;
-    while (!(error= Log_event::read_log_event(&log, packet, log_lock,
+    while (!(error= Log_event::read_log_event(&log, packet,
                                               current_checksum_alg,
                                               log_file_name,
                                               &is_active_binlog)))
@@ -1420,7 +1408,14 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
     if (!is_active_binlog)
       goto_next_binlog= true;
 
-    if (!goto_next_binlog)
+    /*
+      When read_log_event in the above loop returns LOG_READ_BINLOG_LAST_
+      VALID_POS instead of normal EOF, we cannot open next binlog file which
+      may result in skipping of the events in current file. Instead check for
+      error value and try to read an event inside this if statement.
+      LOG_READ_EOF confirms that we reached the end of current file.
+    */
+    if (error != LOG_READ_EOF && !goto_next_binlog)
     {
       /*
         Block until there is more data in the log
@@ -1467,44 +1462,59 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
           has not been updated since last read.
 	*/
 
-        mysql_mutex_lock(log_lock);
-        switch (error= Log_event::read_log_event(&log, packet, (mysql_mutex_t*) 0,
-                                                 current_checksum_alg)) {
+        switch (error= Log_event::read_log_event(&log, packet,
+                                                 current_checksum_alg,
+                                                 log_file_name)) {
 	case 0:
           DBUG_PRINT("info", ("read_log_event returned 0 on line %d",
                               __LINE__));
 	  /* we read successfully, so we'll need to send it to the slave */
-          mysql_mutex_unlock(log_lock);
 	  read_packet = 1;
           p_coord->pos= uint4korr(packet->ptr() + ev_offset + LOG_POS_OFFSET);
           event_type= (Log_event_type)((*packet)[LOG_EVENT_OFFSET+ev_offset]);
           DBUG_ASSERT(event_type != FORMAT_DESCRIPTION_EVENT);
 	  break;
 
-	case LOG_READ_EOF:
+  case LOG_READ_EOF:
+    goto_next_binlog = true;
+    break;
+
+  case LOG_READ_BINLOG_LAST_VALID_POS:
         {
+          /*
+            Take lock_binlog_pos to ensure that we read everything in
+            binlog file. If there is nothing left to read in binlog file,
+            wait until we get a signal from other threads that binlog is
+            updated.
+          */
+          mysql_bin_log.lock_binlog_end_pos();
+
+          /*
+            No need to wait if the the current log is not active or
+            we haven't reached binlog_end_pos.
+
+            Note that is_active may be false positive, but binlog_end_pos
+            is valid here. If rotate thread is about to rotate the log,
+            we will get a singal_update() in open_binlog() which will eventually
+            unblock us and checking is_active() later in read_log_event() will
+            give the valid value.
+          */
+          if (!mysql_bin_log.is_active(log_file_name) ||
+              my_b_tell(&log) < mysql_bin_log.get_binlog_end_pos())
+          {
+            mysql_bin_log.unlock_binlog_end_pos();
+            break;
+          }
+
+          if (thd->server_id==0) // for mysqlbinlog (mysqlbinlog.server_id==0)
+          {
+            mysql_bin_log.unlock_binlog_end_pos();
+            goto end;
+          }
+
           int ret;
           ulong signal_cnt;
 	  DBUG_PRINT("wait",("waiting for data in binary log"));
-	  if (thd->server_id==0) // for mysqlbinlog (mysqlbinlog.server_id==0)
-	  {
-            mysql_mutex_unlock(log_lock);
-            DBUG_EXECUTE_IF("inject_hb_event_on_mysqlbinlog_dump_thread",
-            {
-              /*
-                Send one HB event (with anything in it, content is irrelevant).
-                We just want to check that mysqlbinlog will be able to ignore it.
-
-                Suicide on failure, since if it happens the entire purpose of the
-                test is comprimised.
-               */
-              if (reset_transmit_packet(thd, NO_FLAG, &ev_offset, &errmsg,
-                                        observe_transmission) ||
-                  send_heartbeat_event(net, packet, p_coord, current_checksum_alg))
-                DBUG_SUICIDE();
-            });
-	    goto end;
-	  }
 
 #ifndef DBUG_OFF
           ulong hb_info_counter= 0;
@@ -1519,7 +1529,7 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
               DBUG_ASSERT(heartbeat_ts);
               set_timespec_nsec(*heartbeat_ts, heartbeat_period);
             }
-            thd->ENTER_COND(log_cond, log_lock,
+            thd->ENTER_COND(log_cond, mysql_bin_log.get_binlog_end_pos_lock(),
                             &stage_master_has_sent_all_binlog_to_slave,
                             &old_stage);
             /*
@@ -1581,7 +1591,6 @@ void mysql_binlog_send(THD* thd, char* log_ident, my_off_t pos,
         break;
             
         default:
-          mysql_mutex_unlock(log_lock);
           test_for_non_eof_log_read_errors(error, &errmsg);
           GOTO_ERR;
         }
diff --git sql/rpl_rli.cc sql/rpl_rli.cc
index 9b3c886..db33976 100644
--- sql/rpl_rli.cc
+++ sql/rpl_rli.cc
@@ -106,12 +106,15 @@ Relay_log_info::Relay_log_info(bool is_slave_recovery
   relay_log.set_psi_keys(key_RELAYLOG_LOCK_index,
                          key_RELAYLOG_LOCK_commit,
                          key_RELAYLOG_LOCK_commit_queue,
+                         key_RELAYLOG_LOCK_semisync,
+                         key_RELAYLOG_LOCK_semisync_queue,
                          key_RELAYLOG_LOCK_done,
                          key_RELAYLOG_LOCK_flush_queue,
                          key_RELAYLOG_LOCK_log,
                          key_RELAYLOG_LOCK_sync,
                          key_RELAYLOG_LOCK_sync_queue,
                          key_RELAYLOG_LOCK_xids,
+                         key_RELAYLOG_LOCK_binlog_end_pos,
                          key_RELAYLOG_COND_done,
                          key_RELAYLOG_update_cond,
                          key_RELAYLOG_prep_xids_cond,
diff --git sql/sql_class.h sql/sql_class.h
index 45558f9..244f58f 100644
--- sql/sql_class.h
+++ sql/sql_class.h
@@ -2474,7 +2474,7 @@ public:
       bool xid_written;               // The session wrote an XID
       bool real_commit;               // Is this a "real" commit?
       bool commit_low;                // see MYSQL_BIN_LOG::ordered_commit
-      bool run_hooks;                 // Call the after_commit hook
+      bool run_hooks;                 // Call the before_commit hook
 #ifndef DBUG_OFF
       bool ready_preempt;             // internal in MYSQL_BIN_LOG::ordered_commit
 #endif
